// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package tflite

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type ModelT struct {
	Version uint32
	OperatorCodes []*OperatorCodeT
	Subgraphs []*SubGraphT
	Description string
	Buffers []*BufferT
	MetadataBuffer []int32
	Metadata []*MetadataT
	SignatureDefs []*SignatureDefT
}

func (t *ModelT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	operatorCodesOffset := flatbuffers.UOffsetT(0)
	if t.OperatorCodes != nil {
		operatorCodesLength := len(t.OperatorCodes)
		operatorCodesOffsets := make([]flatbuffers.UOffsetT, operatorCodesLength)
		for j := 0; j < operatorCodesLength; j++ {
			operatorCodesOffsets[j] = t.OperatorCodes[j].Pack(builder)
		}
		ModelStartOperatorCodesVector(builder, operatorCodesLength)
		for j := operatorCodesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(operatorCodesOffsets[j])
		}
		operatorCodesOffset = builder.EndVector(operatorCodesLength)
	}
	subgraphsOffset := flatbuffers.UOffsetT(0)
	if t.Subgraphs != nil {
		subgraphsLength := len(t.Subgraphs)
		subgraphsOffsets := make([]flatbuffers.UOffsetT, subgraphsLength)
		for j := 0; j < subgraphsLength; j++ {
			subgraphsOffsets[j] = t.Subgraphs[j].Pack(builder)
		}
		ModelStartSubgraphsVector(builder, subgraphsLength)
		for j := subgraphsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(subgraphsOffsets[j])
		}
		subgraphsOffset = builder.EndVector(subgraphsLength)
	}
	descriptionOffset := builder.CreateString(t.Description)
	buffersOffset := flatbuffers.UOffsetT(0)
	if t.Buffers != nil {
		buffersLength := len(t.Buffers)
		buffersOffsets := make([]flatbuffers.UOffsetT, buffersLength)
		for j := 0; j < buffersLength; j++ {
			buffersOffsets[j] = t.Buffers[j].Pack(builder)
		}
		ModelStartBuffersVector(builder, buffersLength)
		for j := buffersLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(buffersOffsets[j])
		}
		buffersOffset = builder.EndVector(buffersLength)
	}
	metadataBufferOffset := flatbuffers.UOffsetT(0)
	if t.MetadataBuffer != nil {
		metadataBufferLength := len(t.MetadataBuffer)
		ModelStartMetadataBufferVector(builder, metadataBufferLength)
		for j := metadataBufferLength - 1; j >= 0; j-- {
			builder.PrependInt32(t.MetadataBuffer[j])
		}
		metadataBufferOffset = builder.EndVector(metadataBufferLength)
	}
	metadataOffset := flatbuffers.UOffsetT(0)
	if t.Metadata != nil {
		metadataLength := len(t.Metadata)
		metadataOffsets := make([]flatbuffers.UOffsetT, metadataLength)
		for j := 0; j < metadataLength; j++ {
			metadataOffsets[j] = t.Metadata[j].Pack(builder)
		}
		ModelStartMetadataVector(builder, metadataLength)
		for j := metadataLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(metadataOffsets[j])
		}
		metadataOffset = builder.EndVector(metadataLength)
	}
	signatureDefsOffset := flatbuffers.UOffsetT(0)
	if t.SignatureDefs != nil {
		signatureDefsLength := len(t.SignatureDefs)
		signatureDefsOffsets := make([]flatbuffers.UOffsetT, signatureDefsLength)
		for j := 0; j < signatureDefsLength; j++ {
			signatureDefsOffsets[j] = t.SignatureDefs[j].Pack(builder)
		}
		ModelStartSignatureDefsVector(builder, signatureDefsLength)
		for j := signatureDefsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(signatureDefsOffsets[j])
		}
		signatureDefsOffset = builder.EndVector(signatureDefsLength)
	}
	ModelStart(builder)
	ModelAddVersion(builder, t.Version)
	ModelAddOperatorCodes(builder, operatorCodesOffset)
	ModelAddSubgraphs(builder, subgraphsOffset)
	ModelAddDescription(builder, descriptionOffset)
	ModelAddBuffers(builder, buffersOffset)
	ModelAddMetadataBuffer(builder, metadataBufferOffset)
	ModelAddMetadata(builder, metadataOffset)
	ModelAddSignatureDefs(builder, signatureDefsOffset)
	return ModelEnd(builder)
}

func (rcv *Model) UnPackTo(t *ModelT) {
	t.Version = rcv.Version()
	operatorCodesLength := rcv.OperatorCodesLength()
	t.OperatorCodes = make([]*OperatorCodeT, operatorCodesLength)
	for j := 0; j < operatorCodesLength; j++ {
		x := OperatorCode{}
		rcv.OperatorCodes(&x, j)
		t.OperatorCodes[j] = x.UnPack()
	}
	subgraphsLength := rcv.SubgraphsLength()
	t.Subgraphs = make([]*SubGraphT, subgraphsLength)
	for j := 0; j < subgraphsLength; j++ {
		x := SubGraph{}
		rcv.Subgraphs(&x, j)
		t.Subgraphs[j] = x.UnPack()
	}
	t.Description = string(rcv.Description())
	buffersLength := rcv.BuffersLength()
	t.Buffers = make([]*BufferT, buffersLength)
	for j := 0; j < buffersLength; j++ {
		x := Buffer{}
		rcv.Buffers(&x, j)
		t.Buffers[j] = x.UnPack()
	}
	metadataBufferLength := rcv.MetadataBufferLength()
	t.MetadataBuffer = make([]int32, metadataBufferLength)
	for j := 0; j < metadataBufferLength; j++ {
		t.MetadataBuffer[j] = rcv.MetadataBuffer(j)
	}
	metadataLength := rcv.MetadataLength()
	t.Metadata = make([]*MetadataT, metadataLength)
	for j := 0; j < metadataLength; j++ {
		x := Metadata{}
		rcv.Metadata(&x, j)
		t.Metadata[j] = x.UnPack()
	}
	signatureDefsLength := rcv.SignatureDefsLength()
	t.SignatureDefs = make([]*SignatureDefT, signatureDefsLength)
	for j := 0; j < signatureDefsLength; j++ {
		x := SignatureDef{}
		rcv.SignatureDefs(&x, j)
		t.SignatureDefs[j] = x.UnPack()
	}
}

func (rcv *Model) UnPack() *ModelT {
	if rcv == nil { return nil }
	t := &ModelT{}
	rcv.UnPackTo(t)
	return t
}

type Model struct {
	_tab flatbuffers.Table
}

func GetRootAsModel(buf []byte, offset flatbuffers.UOffsetT) *Model {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Model{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *Model) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Model) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Model) Version() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Model) MutateVersion(n uint32) bool {
	return rcv._tab.MutateUint32Slot(4, n)
}

func (rcv *Model) OperatorCodes(obj *OperatorCode, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Model) OperatorCodesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Model) Subgraphs(obj *SubGraph, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Model) SubgraphsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Model) Description() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Model) Buffers(obj *Buffer, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Model) BuffersLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Model) MetadataBuffer(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *Model) MetadataBufferLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Model) MutateMetadataBuffer(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *Model) Metadata(obj *Metadata, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Model) MetadataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Model) SignatureDefs(obj *SignatureDef, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Model) SignatureDefsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ModelStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func ModelAddVersion(builder *flatbuffers.Builder, version uint32) {
	builder.PrependUint32Slot(0, version, 0)
}
func ModelAddOperatorCodes(builder *flatbuffers.Builder, operatorCodes flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(operatorCodes), 0)
}
func ModelStartOperatorCodesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ModelAddSubgraphs(builder *flatbuffers.Builder, subgraphs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(subgraphs), 0)
}
func ModelStartSubgraphsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ModelAddDescription(builder *flatbuffers.Builder, description flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(description), 0)
}
func ModelAddBuffers(builder *flatbuffers.Builder, buffers flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(buffers), 0)
}
func ModelStartBuffersVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ModelAddMetadataBuffer(builder *flatbuffers.Builder, metadataBuffer flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(metadataBuffer), 0)
}
func ModelStartMetadataBufferVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ModelAddMetadata(builder *flatbuffers.Builder, metadata flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(metadata), 0)
}
func ModelStartMetadataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ModelAddSignatureDefs(builder *flatbuffers.Builder, signatureDefs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(signatureDefs), 0)
}
func ModelStartSignatureDefsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ModelEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
