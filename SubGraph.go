// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package tflite

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type SubGraphT struct {
	Tensors []*TensorT
	Inputs []int32
	Outputs []int32
	Operators []*OperatorT
	Name string
}

func (t *SubGraphT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	tensorsOffset := flatbuffers.UOffsetT(0)
	if t.Tensors != nil {
		tensorsLength := len(t.Tensors)
		tensorsOffsets := make([]flatbuffers.UOffsetT, tensorsLength)
		for j := 0; j < tensorsLength; j++ {
			tensorsOffsets[j] = t.Tensors[j].Pack(builder)
		}
		SubGraphStartTensorsVector(builder, tensorsLength)
		for j := tensorsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(tensorsOffsets[j])
		}
		tensorsOffset = builder.EndVector(tensorsLength)
	}
	inputsOffset := flatbuffers.UOffsetT(0)
	if t.Inputs != nil {
		inputsLength := len(t.Inputs)
		SubGraphStartInputsVector(builder, inputsLength)
		for j := inputsLength - 1; j >= 0; j-- {
			builder.PrependInt32(t.Inputs[j])
		}
		inputsOffset = builder.EndVector(inputsLength)
	}
	outputsOffset := flatbuffers.UOffsetT(0)
	if t.Outputs != nil {
		outputsLength := len(t.Outputs)
		SubGraphStartOutputsVector(builder, outputsLength)
		for j := outputsLength - 1; j >= 0; j-- {
			builder.PrependInt32(t.Outputs[j])
		}
		outputsOffset = builder.EndVector(outputsLength)
	}
	operatorsOffset := flatbuffers.UOffsetT(0)
	if t.Operators != nil {
		operatorsLength := len(t.Operators)
		operatorsOffsets := make([]flatbuffers.UOffsetT, operatorsLength)
		for j := 0; j < operatorsLength; j++ {
			operatorsOffsets[j] = t.Operators[j].Pack(builder)
		}
		SubGraphStartOperatorsVector(builder, operatorsLength)
		for j := operatorsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(operatorsOffsets[j])
		}
		operatorsOffset = builder.EndVector(operatorsLength)
	}
	nameOffset := builder.CreateString(t.Name)
	SubGraphStart(builder)
	SubGraphAddTensors(builder, tensorsOffset)
	SubGraphAddInputs(builder, inputsOffset)
	SubGraphAddOutputs(builder, outputsOffset)
	SubGraphAddOperators(builder, operatorsOffset)
	SubGraphAddName(builder, nameOffset)
	return SubGraphEnd(builder)
}

func (rcv *SubGraph) UnPackTo(t *SubGraphT) {
	tensorsLength := rcv.TensorsLength()
	t.Tensors = make([]*TensorT, tensorsLength)
	for j := 0; j < tensorsLength; j++ {
		x := Tensor{}
		rcv.Tensors(&x, j)
		t.Tensors[j] = x.UnPack()
	}
	inputsLength := rcv.InputsLength()
	t.Inputs = make([]int32, inputsLength)
	for j := 0; j < inputsLength; j++ {
		t.Inputs[j] = rcv.Inputs(j)
	}
	outputsLength := rcv.OutputsLength()
	t.Outputs = make([]int32, outputsLength)
	for j := 0; j < outputsLength; j++ {
		t.Outputs[j] = rcv.Outputs(j)
	}
	operatorsLength := rcv.OperatorsLength()
	t.Operators = make([]*OperatorT, operatorsLength)
	for j := 0; j < operatorsLength; j++ {
		x := Operator{}
		rcv.Operators(&x, j)
		t.Operators[j] = x.UnPack()
	}
	t.Name = string(rcv.Name())
}

func (rcv *SubGraph) UnPack() *SubGraphT {
	if rcv == nil { return nil }
	t := &SubGraphT{}
	rcv.UnPackTo(t)
	return t
}

type SubGraph struct {
	_tab flatbuffers.Table
}

func GetRootAsSubGraph(buf []byte, offset flatbuffers.UOffsetT) *SubGraph {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SubGraph{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *SubGraph) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SubGraph) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SubGraph) Tensors(obj *Tensor, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SubGraph) TensorsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SubGraph) Inputs(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *SubGraph) InputsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SubGraph) MutateInputs(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *SubGraph) Outputs(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *SubGraph) OutputsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SubGraph) MutateOutputs(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *SubGraph) Operators(obj *Operator, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SubGraph) OperatorsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SubGraph) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func SubGraphStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func SubGraphAddTensors(builder *flatbuffers.Builder, tensors flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(tensors), 0)
}
func SubGraphStartTensorsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SubGraphAddInputs(builder *flatbuffers.Builder, inputs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(inputs), 0)
}
func SubGraphStartInputsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SubGraphAddOutputs(builder *flatbuffers.Builder, outputs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(outputs), 0)
}
func SubGraphStartOutputsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SubGraphAddOperators(builder *flatbuffers.Builder, operators flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(operators), 0)
}
func SubGraphStartOperatorsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SubGraphAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(name), 0)
}
func SubGraphEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
