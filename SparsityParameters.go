// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package tflite

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type SparsityParametersT struct {
	TraversalOrder []int32
	BlockMap []int32
	DimMetadata []*DimensionMetadataT
}

func (t *SparsityParametersT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	traversalOrderOffset := flatbuffers.UOffsetT(0)
	if t.TraversalOrder != nil {
		traversalOrderLength := len(t.TraversalOrder)
		SparsityParametersStartTraversalOrderVector(builder, traversalOrderLength)
		for j := traversalOrderLength - 1; j >= 0; j-- {
			builder.PrependInt32(t.TraversalOrder[j])
		}
		traversalOrderOffset = builder.EndVector(traversalOrderLength)
	}
	blockMapOffset := flatbuffers.UOffsetT(0)
	if t.BlockMap != nil {
		blockMapLength := len(t.BlockMap)
		SparsityParametersStartBlockMapVector(builder, blockMapLength)
		for j := blockMapLength - 1; j >= 0; j-- {
			builder.PrependInt32(t.BlockMap[j])
		}
		blockMapOffset = builder.EndVector(blockMapLength)
	}
	dimMetadataOffset := flatbuffers.UOffsetT(0)
	if t.DimMetadata != nil {
		dimMetadataLength := len(t.DimMetadata)
		dimMetadataOffsets := make([]flatbuffers.UOffsetT, dimMetadataLength)
		for j := 0; j < dimMetadataLength; j++ {
			dimMetadataOffsets[j] = t.DimMetadata[j].Pack(builder)
		}
		SparsityParametersStartDimMetadataVector(builder, dimMetadataLength)
		for j := dimMetadataLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(dimMetadataOffsets[j])
		}
		dimMetadataOffset = builder.EndVector(dimMetadataLength)
	}
	SparsityParametersStart(builder)
	SparsityParametersAddTraversalOrder(builder, traversalOrderOffset)
	SparsityParametersAddBlockMap(builder, blockMapOffset)
	SparsityParametersAddDimMetadata(builder, dimMetadataOffset)
	return SparsityParametersEnd(builder)
}

func (rcv *SparsityParameters) UnPackTo(t *SparsityParametersT) {
	traversalOrderLength := rcv.TraversalOrderLength()
	t.TraversalOrder = make([]int32, traversalOrderLength)
	for j := 0; j < traversalOrderLength; j++ {
		t.TraversalOrder[j] = rcv.TraversalOrder(j)
	}
	blockMapLength := rcv.BlockMapLength()
	t.BlockMap = make([]int32, blockMapLength)
	for j := 0; j < blockMapLength; j++ {
		t.BlockMap[j] = rcv.BlockMap(j)
	}
	dimMetadataLength := rcv.DimMetadataLength()
	t.DimMetadata = make([]*DimensionMetadataT, dimMetadataLength)
	for j := 0; j < dimMetadataLength; j++ {
		x := DimensionMetadata{}
		rcv.DimMetadata(&x, j)
		t.DimMetadata[j] = x.UnPack()
	}
}

func (rcv *SparsityParameters) UnPack() *SparsityParametersT {
	if rcv == nil { return nil }
	t := &SparsityParametersT{}
	rcv.UnPackTo(t)
	return t
}

type SparsityParameters struct {
	_tab flatbuffers.Table
}

func GetRootAsSparsityParameters(buf []byte, offset flatbuffers.UOffsetT) *SparsityParameters {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SparsityParameters{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *SparsityParameters) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SparsityParameters) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SparsityParameters) TraversalOrder(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *SparsityParameters) TraversalOrderLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SparsityParameters) MutateTraversalOrder(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *SparsityParameters) BlockMap(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *SparsityParameters) BlockMapLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SparsityParameters) MutateBlockMap(j int, n int32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *SparsityParameters) DimMetadata(obj *DimensionMetadata, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SparsityParameters) DimMetadataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func SparsityParametersStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func SparsityParametersAddTraversalOrder(builder *flatbuffers.Builder, traversalOrder flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(traversalOrder), 0)
}
func SparsityParametersStartTraversalOrderVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SparsityParametersAddBlockMap(builder *flatbuffers.Builder, blockMap flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(blockMap), 0)
}
func SparsityParametersStartBlockMapVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SparsityParametersAddDimMetadata(builder *flatbuffers.Builder, dimMetadata flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(dimMetadata), 0)
}
func SparsityParametersStartDimMetadataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SparsityParametersEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
